import { LOCAL_STORAGE_KEYS } from '../constants.js';
import { showToast } from './toastService.js';

let learningPaths = [];

/**
 * Loads learning paths from localStorage.
 * @private
 */
function loadPaths() {
    try {
        const stored = localStorage.getItem(LOCAL_STORAGE_KEYS.LEARNING_PATHS);
        learningPaths = stored ? JSON.parse(stored) : [];
    } catch (e) {
        console.error("Failed to load learning paths:", e);
        learningPaths = [];
    }
}

/**
 * Saves the current learning paths to localStorage.
 * @private
 */
function savePaths() {
    try {
        localStorage.setItem(LOCAL_STORAGE_KEYS.LEARNING_PATHS, JSON.stringify(learningPaths));
    } catch (e) {
        console.error("Failed to save learning paths:", e);
    }
}

/**
 * Initializes the learning path service by loading data from localStorage.
 * Should be called once on application startup.
 */
export function init() {
    loadPaths();
}

/**
 * Retrieves all saved learning paths.
 * @returns {Array<object>} An array of learning path objects.
 */
export function getAllPaths() {
    return learningPaths;
}

/**
 * Finds a specific learning path by its ID.
 * @param {string} id - The ID of the learning path.
 * @returns {object|undefined} The found learning path object, or undefined.
 */
export function getPathById(id) {
    return learningPaths.find(p => p.id === id);
}

/**
 * Finds a specific learning path by its goal (case-insensitive).
 * @param {string} goal - The goal of the learning path.
 * @returns {object|undefined} The found learning path object, or undefined.
 */
export function getPathByGoal(goal) {
    if (!goal) return undefined;
    const lowerCaseGoal = goal.toLowerCase();
    return learningPaths.find(p => p.goal.toLowerCase() === lowerCaseGoal);
}


/**
 * Finds the most recently created learning path that is not yet completed.
 * @returns {object|undefined} The found learning path object, or undefined.
 */
export function getLatestInProgressPath() {
    const sortedPaths = [...learningPaths].sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
    return sortedPaths.find(p => p.currentStep < p.path.length);
}


/**
 * Creates and saves a new learning path.
 * @param {string} goal - The user-defined goal for the learning path.
 * @param {Array<object>} path - The array of steps generated by the AI.
 * @returns {object} The newly created learning path object.
 */
export function addPath(goal, path) {
    const newPath = {
        id: `path_${Date.now()}`,
        goal,
        path,
        createdAt: new Date().toISOString(),
        currentStep: 0,
        stepScores: {},
        overallTestScores: {},
    };
    learningPaths.unshift(newPath); // Add to the beginning for chronological display
    savePaths();
    showToast('New learning path saved!');
    return newPath;
}

/**
 * Records the user's score for a specific step in a learning path.
 * @param {string} pathId - The ID of the learning path.
 * @param {number} stepIndex - The index of the step within the path.
 * @param {number} score - The number of correct answers.
 * @param {number} totalQuestions - The total number of questions in the quiz.
 */
export function recordStepScore(pathId, stepIndex, score, totalQuestions) {
    const path = getPathById(pathId);
    if (path) {
        // Ensure stepScores object exists
        if (!path.stepScores) {
            path.stepScores = {};
        }
        path.stepScores[stepIndex] = { score, totalQuestions };
        savePaths();
    }
}

/**
 * Records the user's score for a cumulative "Overall Test".
 * @param {string} pathId - The ID of the learning path.
 * @param {number} testIndex - The 1-based index of the overall test.
 * @param {number} score - The number of correct answers.
 * @param {number} totalQuestions - The total number of questions in the quiz.
 */
export function recordOverallTestScore(pathId, testIndex, score, totalQuestions) {
    const path = getPathById(pathId);
    if (path) {
        if (!path.overallTestScores) {
            path.overallTestScores = {};
        }
        path.overallTestScores[testIndex] = { score, totalQuestions };
        savePaths();
    }
}


/**
 * Advances the user's progress in a learning path to the next step.
 * @param {string} pathId - The ID of the learning path to update.
 */
export function completeStep(pathId) {
    const path = getPathById(pathId);
    if (path && path.currentStep < path.path.length - 1) {
        path.currentStep += 1;
        savePaths();
        showToast('Step completed! Well done.');
    } else if (path && path.currentStep === path.path.length - 1) {
        // This was the last step, mark the entire path as complete
        path.currentStep = path.path.length;
        savePaths();
        showToast('Learning path completed! Congratulations!', 'success');
    }
}

/**
 * Deletes a learning path from storage.
 * @param {string} pathId - The ID of the learning path to delete.
 */
export function deletePath(pathId) {
    learningPaths = learningPaths.filter(p => p.id !== pathId);
    savePaths();
    showToast('Learning path deleted.');
}